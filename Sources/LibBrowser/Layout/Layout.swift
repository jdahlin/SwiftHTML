enum Layout {}

extension Layout {
    struct Node {}
}

// CSS takes a source document organized as a tree of elements (which can
// contain a mix of other elements and text nodes) and text nodes (which can
// contain text), and renders it onto a canvas such as your screen, a piece of
// paper, or an audio stream. Although any such source document can be rendered
// with CSS, the most commonly used type is the DOM. [DOM] (Some of these more
// complex tree types might have additional types of nodes, such as the comment
// nodes in the DOM. For the purposes of CSS, all of these additional types of
// nodes are ignored, as if they didn’t exist.)

// To do this, it generates an intermediary structure, the box tree, which
// represents the formatting structure of the rendered document. Each box in the
// box tree represents its corresponding element (or pseudo-element) in space
// and/or time on the canvas, while each text sequence in the box tree likewise
// represents the corresponding contents of its text nodes.

// computed value for each CSS property to each element and text node in the
// To create the box tree, CSS first uses cascading and inheritance, to assign a
// source tree. (See [CSS-CASCADE-3].)

// Then, for each element, CSS generates zero or more boxes as specified by that
// element’s display property. Typically, an element generates a single box, the
// principal box, which represents itself and contains its contents in the box
// tree. However, some display values (e.g. display: list-item) generate more
// than one box (e.g. a principal block box and a child marker box). And some
// values (such as none or contents) cause the element and/or its descendants to
// not generate any boxes at all. Boxes are often referred to by their display
// type—e.g. a box generated by an element with display: block is called a
// “block box” or just a “block”.

// A box is assigned the same styles as its generating element, unless otherwise
// indicated. In general, inherited properties are assigned to the principal
// box, and then inherit through the box tree to any other boxes generated by
// the same element. Non-inherited properties default to applying to the
// principal box, but when the element generates multiple boxes, are sometimes
// defined to apply to a different box: for example, the border properties
// applied to a table element are applied to its table grid box, not to its
// principal table wrapper box. If the value computation process alters the
// styles of those boxes, and the element’s style is requested (such as through
// getComputedStyle()), the element reflects, for each property, the value from
// the box to which that property was applied.

// Similarly, each contiguous sequence of sibling text nodes generates a text
// sequence containing their text contents, which is assigned the same styles as
// the generating text nodes. If the sequence contains no text, however, it does
// not generate a text sequence.

// In constructing the box tree, boxes generated by an element are descendants
// of the principal box of any ancestor elements. In the general case, the
// direct parent box of an element’s principal box is the principal box of its
// nearest ancestor element that generates a box; however, there are some
// exceptions, such as for run-in boxes, display types (like tables) that
// generate multiple container boxes, and intervening anonymous boxes.

// An anonymous box is a box that is not associated with any element. Anonymous
// boxes are generated in certain circumstances to fix up the box tree when it
// requires a particular nested structure that is not provided by the boxes
// generated from the element tree. For example, a table cell box requires a
// particular type of parent box (the table row box), and will generate an
// anonymous table row box around itself if its parent is not a table row box.
// (See [CSS2] § 17.2.1.) Unlike element-generated boxes, whose styles inherit
// strictly through the element tree, anonymous boxes (which only exist in the
// box tree) inherit through their box tree parentage.

// In the course of layout, boxes and text sequences can be broken into multiple
// fragments. This happens, for example, when an inline box and/or text sequence
// is broken across lines, or when a block box is broken across pages or
// columns, in a process called fragmentation. It can also happen due to bidi
// reordering of text (see Applying the Bidirectional Reordering Algorithm in
// CSS Writing Modes) or higher-level display type box splitting, e.g.
// block-in-inline splitting (see CSS2§9.2) or column-spanner-in-block splitting
// (see CSS Multi-column Layout). A box therefore consists of one or more box
// fragments, and a text sequence consists of one or more text fragments. See
// [CSS-BREAK-3] for more information on fragmentation.

class Box {
    var parent: Box?
    var market: Box?
    var principal: Box?

    var children: [Box] = []

    func append(child: Box) {
        children.append(child)
    }
}

// A block container either
// contains only inline-level boxes participating in an inline formatting context,
// or
// contains only block-level boxes participating in a block formatting context
class BlockContainer: Box {}

class AnonymousBox: Box {}

class InlineBox: Box {}

class BlockBox: Box {}

class TableGridBox: Box {}

class TableWrapperBox: Box {}

class TableRowBox: Box {}

class TextSequenceBox: Box {}
